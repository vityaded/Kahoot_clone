<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no" />
  <title>Live Game</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body class="player-view">
  <div class="glow"></div>
  <main class="player-container">
    <div class="player-status" id="lobby-status">Connecting to the game...</div>
    <p id="join-error" class="error"></p>

    <section class="question-board">
      <div class="corner-badge" id="question-progress">Waiting for host...</div>
      <div class="corner-badge timer" id="timer">--</div>
      <div class="question-content">
        <p class="eyebrow">Question</p>
        <h1 id="question-text">Waiting for the host to start...</h1>
        <div id="correct-answer-display" class="correct-answer" aria-live="polite"></div>
        <div id="player-answer-display" class="player-answer" aria-live="polite"></div>
        <div class="media-preview" id="question-media"></div>
      </div>
    </section>

    <section class="response-panel">
      <form id="answer-form" class="answer-card hidden" autocomplete="off">
        <label>
          Type your answer
          <input
            type="text"
            id="answer-input"
            name="response-field"
            autocomplete="new-password"
            autocapitalize="off"
            autocorrect="off"
            spellcheck="false"
          />
        </label>
        <button type="submit">Submit answer</button>
      </form>

      <div id="choice-form" class="answer-card hidden">
        <p class="eyebrow">Choose an option</p>
        <div id="choice-grid" class="choice-grid"></div>
      </div>

      <div class="card leaderboard-card" id="leaderboard-card">
        <div class="leaderboard-header">
          <h2>Leaderboard</h2>
          <p class="muted">Live rankings</p>
        </div>
        <p id="answer-feedback"></p>
        <ul id="leaderboard"></ul>
      </div>
    </section>
  </main>

  <div id="leaderboard-overlay" class="overlay hidden">
    <div class="overlay-card">
      <div class="leaderboard-header">
        <h2>Leaderboard</h2>
        <p id="overlay-hint" class="muted"></p>
      </div>
      <ul id="overlay-leaderboard"></ul>
    </div>
  </div>

  <div id="answer-indicator" class="answer-indicator hidden" aria-live="assertive" aria-atomic="true"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const lobbyStatus = document.getElementById('lobby-status');
    const joinError = document.getElementById('join-error');
    const questionText = document.getElementById('question-text');
    const questionContent = document.querySelector('.question-content');
    const timerEl = document.getElementById('timer');
    const answerForm = document.getElementById('answer-form');
    const answerInput = document.getElementById('answer-input');
    const submitButton = answerForm.querySelector('button');
    const choiceForm = document.getElementById('choice-form');
    const choiceGrid = document.getElementById('choice-grid');
    const answerFeedback = document.getElementById('answer-feedback');
    const leaderboard = document.getElementById('leaderboard');
    const questionMedia = document.getElementById('question-media');
    const questionProgress = document.getElementById('question-progress');
    const overlay = document.getElementById('leaderboard-overlay');
    const overlayList = document.getElementById('overlay-leaderboard');
    const overlayHint = document.getElementById('overlay-hint');
    const leaderboardCard = document.getElementById('leaderboard-card');
    const correctAnswerDisplay = document.getElementById('correct-answer-display');
    const playerAnswerDisplay = document.getElementById('player-answer-display');
    const questionBoard = document.querySelector('.question-board');
    const answerIndicator = document.getElementById('answer-indicator');

    function applyAnswerInputSafeguards() {
      answerForm.setAttribute('autocomplete', 'off');
      answerInput.setAttribute('name', 'response-field');
      answerInput.setAttribute('autocomplete', 'new-password');
      answerInput.setAttribute('autocapitalize', 'off');
      answerInput.setAttribute('autocorrect', 'off');
      answerInput.setAttribute('spellcheck', 'false');
    }

    function normalizeChoiceValue(value) {
      return String(value ?? '').trim();
    }

    function clearChoiceFeedback() {
      choiceGrid.querySelectorAll('.choice-button').forEach((button) => {
        button.classList.remove('selected', 'correct', 'incorrect');
      });
    }

    function renderChoiceButtons(options = []) {
      choiceGrid.innerHTML = '';
      const list = Array.isArray(options) ? options : [];
      if (!list.length) return;
      list.forEach((option) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'choice-button';
        button.textContent = option;
        button.dataset.option = option;
        button.addEventListener('click', () => submitChoice(option));
        choiceGrid.appendChild(button);
      });
    }

    function markSelectedChoice(option) {
      choiceGrid.querySelectorAll('.choice-button').forEach((button) => {
        button.classList.toggle('selected', button.textContent === option);
      });
    }

    function revealChoiceResult(correctAnswer, playerAnswer) {
      const normalizedCorrect = normalizeChoiceValue(correctAnswer);
      const normalizedPlayer = normalizeChoiceValue(playerAnswer);
      if (!normalizedCorrect) return;
      choiceGrid.querySelectorAll('.choice-button').forEach((button) => {
        const optionValue = normalizeChoiceValue(button.dataset.option || button.textContent);
        if (!optionValue) return;
        if (optionValue === normalizedCorrect) {
          button.classList.add('correct');
        } else if (normalizedPlayer && optionValue === normalizedPlayer) {
          button.classList.add('incorrect');
        }
      });
    }

    function submitChoice(option) {
      if (!currentQuizId || playerHasAnswered) return;
      setAnswerWaiting(true);
      socket.emit('player:answer', {
        quizId: currentQuizId,
        answer: option,
      });
      lastSubmittedAnswer = option;
      playerHasAnswered = true;
      answerFeedback.textContent = '';
      answerFeedback.className = '';
      markSelectedChoice(option);
    }

    function showAnswerMode(type, options = []) {
      currentQuestionType = type === 'multiple' ? 'multiple' : 'open';
      if (currentQuestionType === 'multiple') {
        answerForm.classList.add('hidden');
        choiceForm.classList.remove('hidden');
        clearChoiceFeedback();
        renderChoiceButtons(options);
      } else {
        choiceForm.classList.add('hidden');
        choiceGrid.innerHTML = '';
        answerForm.classList.remove('hidden');
      }
    }

    const playerIdFromStorage = localStorage.getItem('playerId');
    let storedPlayerId = playerIdFromStorage;
    let storedQuiz = localStorage.getItem('quizCode');
    let storedName = localStorage.getItem('playerName');

    function generatePlayerId() {
      if (window.crypto?.randomUUID) return window.crypto.randomUUID();
      return Math.random().toString(36).slice(2, 12);
    }

    if (!storedPlayerId) {
      storedPlayerId = generatePlayerId();
      localStorage.setItem('playerId', storedPlayerId);
    }

    let currentQuizId = null;
    let timerInterval = null;
    let lobbyCountdown = null;
    let hasJoinedOnce = Boolean(playerIdFromStorage);
    let inputEngaged = false;
    let baseViewportHeight = window.visualViewport?.height || window.innerHeight;
    let lastSubmittedAnswer = '';
    let playerHasAnswered = false;
    let currentQuestionType = 'open';

    function joinQuiz(message = 'Joining game...') {
      storedName = localStorage.getItem('playerName');
      storedQuiz = localStorage.getItem('quizCode');

      if (!storedName || !storedQuiz) {
        window.location.href = '/join.html';
        return;
      }

      lobbyStatus.textContent = message;
      socket.emit('player:join', {
        quizId: storedQuiz,
        name: storedName,
        playerId: storedPlayerId,
      });
    }

    function attemptReconnect() {
      lobbyStatus.textContent = 'Reconnecting to the game...';
      socket.emit('player:reconnect', { playerId: storedPlayerId, quizId: storedQuiz });
    }

    socket.on('connect', () => {
      attemptReconnect();
    });

    socket.on('reconnect', () => {
      attemptReconnect();
    });

    socket.on('player:joined', ({ quizId, title, totalQuestions, playerId }) => {
      currentQuizId = quizId;
      if (playerId) {
        storedPlayerId = playerId;
        localStorage.setItem('playerId', playerId);
        hasJoinedOnce = true;
      }
      if (quizId) {
        storedQuiz = quizId;
        localStorage.setItem('quizCode', quizId);
      }
      joinError.textContent = '';
      lobbyStatus.textContent = `Joined "${title}". Waiting for the first question...`;
      answerFeedback.textContent = '';
    });

    socket.on('player:reconnected', ({ quizId, title, playerId, name }) => {
      currentQuizId = quizId;
      joinError.textContent = '';
      lobbyStatus.textContent = `Reconnected to "${title}". Restoring your spot...`;
      storedPlayerId = playerId;
      storedName = name || storedName;
      storedQuiz = quizId;
      localStorage.setItem('playerId', storedPlayerId);
      if (storedName) localStorage.setItem('playerName', storedName);
      if (storedQuiz) localStorage.setItem('quizCode', storedQuiz);
      hasJoinedOnce = true;
    });

    socket.on('player:reconnectFailed', () => {
      if (storedName && storedQuiz) {
        joinQuiz('Rejoining game...');
      } else {
        window.location.href = '/join.html';
      }
    });

    socket.on('player:error', (message) => {
      joinError.textContent = message;
      lobbyStatus.textContent = 'Unable to join. Please re-enter the code and nickname.';
    });

    socket.on('question:start', ({ prompt, index, total, duration, media, type, options }) => {
      questionProgress.textContent = `Question ${index} of ${total}`;
      questionText.textContent = prompt;
      answerFeedback.textContent = '';
      answerFeedback.className = '';
      showCorrectAnswer('');
      showPlayerAnswer('');
      lobbyStatus.textContent = '';
      resetInputEngagement();
      applyAnswerInputSafeguards();
      showAnswerMode(type, options);
      setAnswerWaiting(false);
      answerInput.value = '';
      lastSubmittedAnswer = '';
      playerHasAnswered = false;
      stopMedia(questionMedia);
      renderMedia(media);
      const mediaEl = getActiveMedia(questionMedia);
      if (mediaEl) {
        attemptAutoplay(mediaEl, questionMedia);
      }
      startTimer(duration);
      hideOverlay();
      stopLobbyCountdown();
      toggleLeaderboard(false);
    });

    socket.on('question:end', ({ correctAnswer }) => {
      stopTimer();
      showCorrectAnswer(`Correct answer: ${correctAnswer}`);
      const answerText = playerHasAnswered && lastSubmittedAnswer ? lastSubmittedAnswer : 'No answer submitted';
      showPlayerAnswer(`Your answer: ${answerText}`);
      if (currentQuestionType === 'multiple') {
        answerForm.classList.add('hidden');
        choiceForm.classList.remove('hidden');
        revealChoiceResult(correctAnswer, lastSubmittedAnswer);
        setAnswerWaiting(true);
      } else {
        answerForm.classList.add('hidden');
        choiceForm.classList.add('hidden');
        setAnswerWaiting(false);
      }
      stopMedia(questionMedia);
      questionMedia.innerHTML = '';
      resetInputEngagement();
      timerEl.textContent = 'Time!';
      toggleLeaderboard(false);
    });

    socket.on('question:timeAdjusted', ({ duration, timeRemaining }) => {
      const nextRemaining = Number.isFinite(timeRemaining) ? timeRemaining : duration;
      if (!Number.isFinite(nextRemaining)) return;
      startTimer(nextRemaining);
    });

    socket.on('leaderboard:show', ({ leaderboard: board, duration }) => {
      hideOverlay();
    });

    socket.on('quiz:finished', () => {
      stopTimer();
      questionProgress.textContent = 'Quiz finished';
      questionText.textContent = 'Quiz finished! Check the leaderboard for final scores.';
      answerForm.classList.add('hidden');
      choiceForm.classList.add('hidden');
      setAnswerWaiting(false);
      resetInputEngagement();
      stopMedia(questionMedia);
      questionMedia.innerHTML = '';
      timerEl.textContent = '--';
      toggleLeaderboard(false);
    });

    socket.on('quiz:ended', () => {
      stopTimer();
      questionProgress.textContent = 'Quiz closed';
      questionText.textContent = 'The host left the game. Quiz closed.';
      answerForm.classList.add('hidden');
      choiceForm.classList.add('hidden');
      setAnswerWaiting(false);
      resetInputEngagement();
      stopMedia(questionMedia);
      questionMedia.innerHTML = '';
      timerEl.textContent = '--';
      toggleLeaderboard(false);
    });

    socket.on('quiz:terminated', ({ reason }) => {
      stopTimer();
      questionProgress.textContent = 'Quiz closed';
      questionText.textContent = reason === 'deleted' ? 'This quiz was deleted by the teacher.' : 'Quiz closed.';
      answerForm.classList.add('hidden');
      choiceForm.classList.add('hidden');
      questionMedia.innerHTML = '';
      timerEl.textContent = '--';
    });

    socket.on('player:answerResult', ({ correct, partial, earned, correctAnswer, playerAnswer }) => {
      if (correct) {
        answerFeedback.textContent = `Correct! +${earned} points`;
        answerFeedback.className = 'success';
        showAnswerIndicator('correct');
      } else if (partial) {
        answerFeedback.textContent = `Almost! +${earned} points`;
        answerFeedback.className = 'warning';
        showAnswerIndicator('partial');
      } else {
        answerFeedback.textContent = 'Incorrect';
        answerFeedback.className = 'error';
        showAnswerIndicator('incorrect');
      }
      showCorrectAnswer(`Correct answer: ${correctAnswer}`);
      lastSubmittedAnswer = playerAnswer ?? lastSubmittedAnswer;
      const answerText = lastSubmittedAnswer || 'No answer submitted';
      showPlayerAnswer(`Your answer: ${answerText}`);
      playerHasAnswered = true;
      resetInputEngagement();
      if (currentQuestionType === 'multiple') {
        answerForm.classList.add('hidden');
        choiceForm.classList.remove('hidden');
        revealChoiceResult(correctAnswer, lastSubmittedAnswer);
        setAnswerWaiting(true);
      } else {
        answerForm.classList.add('hidden');
        choiceForm.classList.add('hidden');
        setAnswerWaiting(false);
      }
    });

    socket.on('leaderboard:update', (players) => {
      renderLeaderboard(players);
    });

    socket.on('player:state', ({ questionActive, question, timeRemaining, leaderboard: board, hasAnswered }) => {
      renderLeaderboard(board);

      if (questionActive && question) {
        questionProgress.textContent = `Question ${question.index} of ${question.total}`;
        questionText.textContent = question.prompt;
        stopMedia(questionMedia);
        renderMedia(question.media);
        const mediaEl = getActiveMedia(questionMedia);
        if (mediaEl) {
          attemptAutoplay(mediaEl, questionMedia);
        }
        hideOverlay();
        stopLobbyCountdown();
        lobbyStatus.textContent = '';
        setAnswerWaiting(hasAnswered);
        playerHasAnswered = hasAnswered;
        showAnswerMode(question.type, question.options || []);
        if (hasAnswered) {
          answerForm.classList.add('hidden');
          choiceForm.classList.add('hidden');
          answerFeedback.textContent = '';
          answerFeedback.className = '';
        } else {
          if (currentQuestionType === 'multiple') {
            choiceForm.classList.remove('hidden');
            answerForm.classList.add('hidden');
          } else {
            answerForm.classList.remove('hidden');
            choiceForm.classList.add('hidden');
          }
          resetInputEngagement();
          answerInput.value = '';
          answerFeedback.textContent = '';
          answerFeedback.className = '';
        }
        const remaining = timeRemaining ?? question.duration;
        startTimer(remaining);
        toggleLeaderboard(false);
      } else {
        stopTimer();
        timerEl.textContent = '--';
        questionProgress.textContent = 'Waiting for host...';
        questionText.textContent = 'Waiting for the host to start...';
        answerForm.classList.add('hidden');
        choiceForm.classList.add('hidden');
        setAnswerWaiting(false);
        resetInputEngagement();
        answerFeedback.textContent = '';
        answerFeedback.className = '';
        showCorrectAnswer('');
        showPlayerAnswer('');
        stopMedia(questionMedia);
        questionMedia.innerHTML = '';
        toggleLeaderboard(false);
      }
    });

    socket.on('quiz:countdown', ({ seconds }) => {
      startLobbyCountdown(seconds);
    });

    socket.on('quiz:countdownCancelled', () => {
      stopLobbyCountdown();
    });

    function handleImmediateSubmit(event) {
      if (!answerForm.requestSubmit || submitButton.disabled) return;
      if (!currentQuizId) return;
      const trimmedAnswer = answerInput.value.trim();
      if (!trimmedAnswer) return;

      event.preventDefault();
      answerForm.requestSubmit();
    }

    answerForm.addEventListener('submit', (event) => {
      event.preventDefault();
      if (!currentQuizId) return;
      const trimmedAnswer = answerInput.value.trim();
      if (!trimmedAnswer) return;
      setAnswerWaiting(true);
      socket.emit('player:answer', {
        quizId: currentQuizId,
        answer: trimmedAnswer,
      });
      lastSubmittedAnswer = trimmedAnswer;
      playerHasAnswered = true;
      answerFeedback.textContent = '';
      answerFeedback.className = '';
    });

    submitButton.addEventListener('pointerdown', handleImmediateSubmit);
    submitButton.addEventListener('touchstart', handleImmediateSubmit);

    answerInput.addEventListener('focus', handleInputFocus);
    answerInput.addEventListener('blur', handleInputBlur);

    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', () => {
        if (!inputEngaged) {
          baseViewportHeight = Math.max(baseViewportHeight, window.visualViewport.height);
          return;
        }

        const heightLoss = baseViewportHeight - window.visualViewport.height;
        if (heightLoss > 120) {
          window.requestAnimationFrame(adjustQuestionPosition);
        }
      });
    }

    window.addEventListener('resize', () => {
      if (!inputEngaged) {
        baseViewportHeight = Math.max(baseViewportHeight, window.innerHeight);
        return;
      }

      window.requestAnimationFrame(adjustQuestionPosition);
    });

    function showCorrectAnswer(text) {
      correctAnswerDisplay.textContent = text;
      correctAnswerDisplay.classList.toggle('visible', Boolean(text));
    }

    function showPlayerAnswer(text) {
      playerAnswerDisplay.textContent = text;
      playerAnswerDisplay.classList.toggle('visible', Boolean(text));
    }

    function showAnswerIndicator(status) {
      let label = '✕';
      if (status === 'correct') label = '✓';
      if (status === 'partial') label = 'OK';

      answerIndicator.textContent = label;
      answerIndicator.classList.remove('hidden', 'correct', 'incorrect', 'partial');
      const className = status === 'correct' ? 'correct' : status === 'partial' ? 'partial' : 'incorrect';
      answerIndicator.classList.add(className);
      answerIndicator.classList.add('visible');
      setTimeout(() => {
        answerIndicator.classList.remove('visible');
        answerIndicator.classList.add('hidden');
      }, 1400);
    }

    function setAnswerWaiting(isWaiting) {
      answerInput.disabled = isWaiting;
      submitButton.disabled = isWaiting;
      choiceGrid.querySelectorAll('button').forEach((button) => {
        button.disabled = isWaiting;
      });
    }

    function handleInputFocus() {
      inputEngaged = true;
      document.body.classList.add('input-engaged');
      waitForKeyboardAndAdjust();
    }

    function handleInputBlur() {
      resetInputEngagement();
    }

    function resetInputEngagement() {
      inputEngaged = false;
      document.body.classList.remove('input-engaged');
      resetQuestionShift();
    }

    function waitForKeyboardAndAdjust(attempt = 0) {
      if (!inputEngaged) return;

      const viewportHeight = window.visualViewport?.height || window.innerHeight;
      const heightLoss = baseViewportHeight - viewportHeight;
      const keyboardLikelyOpen = heightLoss > 120;

      if (keyboardLikelyOpen) {
        window.requestAnimationFrame(adjustQuestionPosition);
        return;
      }

      if (attempt < 6) {
        setTimeout(() => waitForKeyboardAndAdjust(attempt + 1), 80);
      } else {
        window.requestAnimationFrame(adjustQuestionPosition);
      }
    }

    function adjustQuestionPosition() {
      if (!questionBoard || !questionContent || !answerInput) return;
      const questionRect = questionContent.getBoundingClientRect();
      const inputRect = answerInput.getBoundingClientRect();
      const desiredGap = 12;
      const rawShift = inputRect.top - questionRect.bottom - desiredGap;
      const boardRect = questionBoard.getBoundingClientRect();
      const maxShift = Math.max(0, boardRect.bottom - questionRect.bottom - 8);
      const safeShift = Math.min(Math.max(rawShift, 0), maxShift);

      if (safeShift > 2) {
        questionBoard.style.setProperty('--question-shift', `${safeShift}px`);
        questionBoard.classList.add('question-shifted');
      } else {
        resetQuestionShift();
      }
    }

    function resetQuestionShift() {
      questionBoard?.style.removeProperty('--question-shift');
      questionBoard?.classList.remove('question-shifted');
    }

    function startTimer(seconds) {
      stopTimer();
      let remaining = Math.round(seconds);
      if (!Number.isFinite(remaining) || remaining <= 0) {
        timerEl.textContent = 'Time!';
        return;
      }
      timerEl.textContent = `${remaining}s`;
      timerInterval = setInterval(() => {
        remaining -= 1;
        if (remaining <= 0) {
          timerEl.textContent = 'Time!';
          stopTimer();
          return;
        }
        timerEl.textContent = `${remaining}s`;
      }, 1000);
    }

    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    function renderLeaderboard(players) {
      leaderboard.innerHTML = '';
      if (!Array.isArray(players)) return;
      players.forEach((player, index) => {
        const li = document.createElement('li');
        const correctCount = Number(player.correctCount) || 0;
        li.innerHTML = `<span>${index + 1}. ${player.name}</span><span>${player.score} pts · ${correctCount} correct</span>`;
        leaderboard.appendChild(li);
      });
    }

    function getActiveMedia(container) {
      return container?.querySelector('video, audio') || null;
    }

    function removeTapOverlay(container) {
      container?.querySelector('.tap-to-play-overlay')?.remove();
    }

    function stopMedia(container) {
      const mediaEl = getActiveMedia(container);
      if (mediaEl) {
        mediaEl.pause();
        mediaEl.currentTime = 0;
      }
      removeTapOverlay(container);
    }

    function ensureMediaContainer(container) {
      if (!container) return;
      const currentPosition = window.getComputedStyle(container).position;
      if (currentPosition === 'static') {
        container.style.position = 'relative';
      }
    }

    function showTapToPlayOverlay(container, mediaEl, label = 'Tap to play') {
      if (!container || !mediaEl) return;
      ensureMediaContainer(container);
      removeTapOverlay(container);

      const overlay = document.createElement('button');
      overlay.type = 'button';
      overlay.textContent = label;
      overlay.className = 'tap-to-play-overlay';
      overlay.style.position = 'absolute';
      overlay.style.inset = '0';
      overlay.style.display = 'flex';
      overlay.style.alignItems = 'center';
      overlay.style.justifyContent = 'center';
      overlay.style.background = 'rgba(0, 0, 0, 0.35)';
      overlay.style.color = '#fff';
      overlay.style.border = 'none';
      overlay.style.fontWeight = '600';
      overlay.style.cursor = 'pointer';
      overlay.style.backdropFilter = 'blur(1px)';

      const removeOverlay = () => removeTapOverlay(container);
      overlay.addEventListener('click', () => {
        mediaEl.muted = false;
        const resumePromise = mediaEl.play();
        if (resumePromise?.then) {
          resumePromise.then(removeOverlay).catch(() => {});
        } else {
          removeOverlay();
        }
      });
      mediaEl.addEventListener('playing', removeOverlay, { once: true });

      container.appendChild(overlay);
    }

    function attemptAutoplay(mediaEl, container) {
      if (!mediaEl) return;
      mediaEl.currentTime = 0;
      if (mediaEl.tagName === 'VIDEO') {
        mediaEl.playsInline = true;
      }
      const removeOverlay = () => removeTapOverlay(container);
      const playPromise = mediaEl.play();
      if (!playPromise?.catch) {
        return;
      }
      playPromise.then(removeOverlay).catch(() => {
        mediaEl.muted = true;
        const mutedAttempt = mediaEl.play();
        if (mutedAttempt?.catch) {
          mutedAttempt.then(() => {
            showTapToPlayOverlay(container, mediaEl, 'Tap to unmute');
          }).catch(() => {
            showTapToPlayOverlay(container, mediaEl);
          });
        } else {
          showTapToPlayOverlay(container, mediaEl, 'Tap to unmute');
        }
      });
    }

    function renderMedia(media) {
      stopMedia(questionMedia);
      questionMedia.innerHTML = '';
      removeTapOverlay(questionMedia);
      if (!media?.src || !media?.type) return;

      if (media.type === 'image') {
        const img = document.createElement('img');
        img.src = media.src;
        img.alt = 'Question media';
        questionMedia.appendChild(img);
        return;
      }

      if (media.type === 'audio') {
        const audio = document.createElement('audio');
        audio.src = media.src;
        audio.controls = true;
        audio.autoplay = true;
        audio.preload = 'auto';
        questionMedia.appendChild(audio);
        return;
      }

      if (media.type === 'video') {
        const video = document.createElement('video');
        video.src = media.src;
        video.controls = true;
        video.autoplay = true;
        video.preload = 'auto';
        video.playsInline = true;
        questionMedia.appendChild(video);
      }
    }

    function hideOverlay() {
      overlay.classList.add('hidden');
      overlayList.innerHTML = '';
    }

    function toggleLeaderboard(show) {
      leaderboardCard.classList.add('hidden');
    }

    function startLobbyCountdown(seconds) {
      stopLobbyCountdown();
      let remaining = seconds;
      lobbyStatus.textContent = `Game starting in ${remaining}s...`;
      lobbyCountdown = setInterval(() => {
        remaining -= 1;
        lobbyStatus.textContent = `Game starting in ${Math.max(remaining, 0)}s...`;
        if (remaining <= 0) {
          stopLobbyCountdown();
        }
      }, 1000);
    }

    function stopLobbyCountdown() {
      if (lobbyCountdown) {
        clearInterval(lobbyCountdown);
        lobbyCountdown = null;
      }
      lobbyStatus.textContent = '';
    }

  </script>
</body>
</html>
