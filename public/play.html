<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no" />
  <title>Live Game</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body class="player-view">
  <div class="glow"></div>
  <div id="flash-overlay" class="flash-overlay"></div>
  <div id="answer-result-overlay" class="result-overlay hidden" aria-live="polite">
    <div id="answer-result-message" class="result-message"></div>
  </div>
  <main class="player-container">
    <div class="player-status" id="lobby-status">Connecting to the game...</div>
    <p id="join-error" class="error"></p>

    <section class="question-board">
      <div class="corner-badge" id="question-progress">Waiting for host...</div>
      <div class="corner-badge timer" id="timer">--</div>
      <div class="question-content">
        <p class="eyebrow">Question</p>
        <h1 id="question-text">Waiting for the host to start...</h1>
        <div id="correct-answer-display" class="correct-answer" aria-live="polite"></div>
        <div class="media-preview" id="question-media"></div>
      </div>
    </section>

    <section class="response-panel">
      <form id="answer-form" class="answer-card hidden" autocomplete="off">
        <label>
          Type your answer
          <input
            type="text"
            id="answer-input"
            name="response-field"
            autocomplete="new-password"
            autocapitalize="off"
            autocorrect="off"
            spellcheck="false"
          />
        </label>
        <button type="submit">Submit answer</button>
      </form>

      <div class="card leaderboard-card" id="leaderboard-card">
        <div class="leaderboard-header">
          <h2>Leaderboard</h2>
          <p class="muted">Live rankings</p>
        </div>
        <p id="answer-feedback"></p>
        <ul id="leaderboard"></ul>
      </div>
    </section>
  </main>

  <div id="leaderboard-overlay" class="overlay hidden">
    <div class="overlay-card">
      <div class="leaderboard-header">
        <h2>Leaderboard</h2>
        <p id="overlay-hint" class="muted"></p>
      </div>
      <ul id="overlay-leaderboard"></ul>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const lobbyStatus = document.getElementById('lobby-status');
    const joinError = document.getElementById('join-error');
    const questionText = document.getElementById('question-text');
    const questionContent = document.querySelector('.question-content');
    const timerEl = document.getElementById('timer');
    const answerForm = document.getElementById('answer-form');
    const answerInput = document.getElementById('answer-input');
    const submitButton = answerForm.querySelector('button');
    const answerFeedback = document.getElementById('answer-feedback');
    const leaderboard = document.getElementById('leaderboard');
    const questionMedia = document.getElementById('question-media');
    const questionProgress = document.getElementById('question-progress');
    const overlay = document.getElementById('leaderboard-overlay');
    const overlayList = document.getElementById('overlay-leaderboard');
    const overlayHint = document.getElementById('overlay-hint');
    const leaderboardCard = document.getElementById('leaderboard-card');
    const correctAnswerDisplay = document.getElementById('correct-answer-display');
    const flashOverlay = document.getElementById('flash-overlay');
    const questionBoard = document.querySelector('.question-board');
    const resultOverlay = document.getElementById('answer-result-overlay');
    const resultMessage = document.getElementById('answer-result-message');

    function applyAnswerInputSafeguards() {
      answerForm.setAttribute('autocomplete', 'off');
      answerInput.setAttribute('name', 'response-field');
      answerInput.setAttribute('autocomplete', 'new-password');
      answerInput.setAttribute('autocapitalize', 'off');
      answerInput.setAttribute('autocorrect', 'off');
      answerInput.setAttribute('spellcheck', 'false');
    }

    const playerIdFromStorage = localStorage.getItem('playerId');
    let storedPlayerId = playerIdFromStorage;
    let storedQuiz = localStorage.getItem('quizCode');
    let storedName = localStorage.getItem('playerName');

    function generatePlayerId() {
      if (window.crypto?.randomUUID) return window.crypto.randomUUID();
      return Math.random().toString(36).slice(2, 12);
    }

    if (!storedPlayerId) {
      storedPlayerId = generatePlayerId();
      localStorage.setItem('playerId', storedPlayerId);
    }

    let currentQuizId = null;
    let timerInterval = null;
    let lobbyCountdown = null;
    let hasJoinedOnce = Boolean(playerIdFromStorage);
    let resultOverlayTimeout = null;
    let inputEngaged = false;
    let baseViewportHeight = window.visualViewport?.height || window.innerHeight;
    const RESULT_OVERLAY_DURATION = 3000;

    function joinQuiz(message = 'Joining game...') {
      storedName = localStorage.getItem('playerName');
      storedQuiz = localStorage.getItem('quizCode');

      if (!storedName || !storedQuiz) {
        window.location.href = '/join.html';
        return;
      }

      lobbyStatus.textContent = message;
      socket.emit('player:join', {
        quizId: storedQuiz,
        name: storedName,
        playerId: storedPlayerId,
      });
    }

    function attemptReconnect() {
      lobbyStatus.textContent = 'Reconnecting to the game...';
      socket.emit('player:reconnect', { playerId: storedPlayerId, quizId: storedQuiz });
    }

    socket.on('connect', () => {
      attemptReconnect();
    });

    socket.on('reconnect', () => {
      attemptReconnect();
    });

    socket.on('player:joined', ({ quizId, title, totalQuestions, playerId }) => {
      currentQuizId = quizId;
      if (playerId) {
        storedPlayerId = playerId;
        localStorage.setItem('playerId', playerId);
        hasJoinedOnce = true;
      }
      if (quizId) {
        storedQuiz = quizId;
        localStorage.setItem('quizCode', quizId);
      }
      joinError.textContent = '';
      lobbyStatus.textContent = `Joined "${title}". Waiting for the first question...`;
      answerFeedback.textContent = '';
    });

    socket.on('player:reconnected', ({ quizId, title, playerId, name }) => {
      currentQuizId = quizId;
      joinError.textContent = '';
      lobbyStatus.textContent = `Reconnected to "${title}". Restoring your spot...`;
      storedPlayerId = playerId;
      storedName = name || storedName;
      storedQuiz = quizId;
      localStorage.setItem('playerId', storedPlayerId);
      if (storedName) localStorage.setItem('playerName', storedName);
      if (storedQuiz) localStorage.setItem('quizCode', storedQuiz);
      hasJoinedOnce = true;
    });

    socket.on('player:reconnectFailed', () => {
      if (storedName && storedQuiz) {
        joinQuiz('Rejoining game...');
      } else {
        window.location.href = '/join.html';
      }
    });

    socket.on('player:error', (message) => {
      joinError.textContent = message;
      lobbyStatus.textContent = 'Unable to join. Please re-enter the code and nickname.';
    });

    socket.on('question:start', ({ prompt, index, total, duration, media }) => {
      questionProgress.textContent = `Question ${index} of ${total}`;
      questionText.textContent = prompt;
      answerFeedback.textContent = '';
      answerFeedback.className = '';
      showCorrectAnswer('');
      lobbyStatus.textContent = '';
      resetInputEngagement();
      applyAnswerInputSafeguards();
      answerForm.classList.remove('hidden');
      setAnswerWaiting(false);
      answerInput.value = '';
      hideResultOverlay();
      renderMedia(media);
      startTimer(duration);
      hideOverlay();
      stopLobbyCountdown();
      toggleLeaderboard(false);
    });

    socket.on('question:end', ({ correctAnswer }) => {
      stopTimer();
      questionText.textContent = `Time's up! Correct answer: ${correctAnswer}`;
      showCorrectAnswer(`Correct answer: ${correctAnswer}`);
      answerForm.classList.add('hidden');
      setAnswerWaiting(false);
      resetInputEngagement();
      questionMedia.innerHTML = '';
      timerEl.textContent = 'Time!';
      toggleLeaderboard(false);
    });

    socket.on('leaderboard:show', ({ leaderboard: board, duration }) => {
      hideOverlay();
    });

    socket.on('quiz:finished', () => {
      stopTimer();
      questionProgress.textContent = 'Quiz finished';
      questionText.textContent = 'Quiz finished! Check the leaderboard for final scores.';
      answerForm.classList.add('hidden');
      setAnswerWaiting(false);
      resetInputEngagement();
      questionMedia.innerHTML = '';
      timerEl.textContent = '--';
      toggleLeaderboard(false);
    });

    socket.on('quiz:ended', () => {
      stopTimer();
      questionProgress.textContent = 'Quiz closed';
      questionText.textContent = 'The host left the game. Quiz closed.';
      answerForm.classList.add('hidden');
      setAnswerWaiting(false);
      resetInputEngagement();
      questionMedia.innerHTML = '';
      timerEl.textContent = '--';
      toggleLeaderboard(false);
    });

    socket.on('player:answerResult', ({ correct, earned, correctAnswer }) => {
      if (correct) {
        answerFeedback.textContent = `Correct! +${earned} points`;
        answerFeedback.className = 'success';
      } else {
        answerFeedback.textContent = 'Incorrect';
        answerFeedback.className = 'error';
      }
      showCorrectAnswer(`Correct answer: ${correctAnswer}`);
      resetInputEngagement();
      triggerFlash(correct);
      showResultOverlay(correct);
      answerForm.classList.add('hidden');
      setAnswerWaiting(false);
    });

    socket.on('leaderboard:update', (players) => {
      renderLeaderboard(players);
    });

    socket.on('player:state', ({ questionActive, question, timeRemaining, leaderboard: board, hasAnswered }) => {
      renderLeaderboard(board);

      if (questionActive && question) {
        questionProgress.textContent = `Question ${question.index} of ${question.total}`;
        questionText.textContent = question.prompt;
        renderMedia(question.media);
        hideOverlay();
        stopLobbyCountdown();
        lobbyStatus.textContent = '';
        setAnswerWaiting(hasAnswered);
        if (hasAnswered) {
          answerForm.classList.add('hidden');
          answerFeedback.textContent = 'Answer received!';
          answerFeedback.className = 'success';
        } else {
          answerForm.classList.remove('hidden');
          resetInputEngagement();
          answerInput.value = '';
          answerFeedback.textContent = '';
          answerFeedback.className = '';
        }
        const remaining = timeRemaining ?? question.duration;
        startTimer(remaining);
        toggleLeaderboard(false);
      } else {
        stopTimer();
        timerEl.textContent = '--';
        questionProgress.textContent = 'Waiting for host...';
        questionText.textContent = 'Waiting for the host to start...';
        answerForm.classList.add('hidden');
        setAnswerWaiting(false);
        resetInputEngagement();
        answerFeedback.textContent = '';
        answerFeedback.className = '';
        showCorrectAnswer('');
        questionMedia.innerHTML = '';
        toggleLeaderboard(false);
        hideResultOverlay();
      }
    });

    socket.on('quiz:countdown', ({ seconds }) => {
      startLobbyCountdown(seconds);
    });

    function handleImmediateSubmit(event) {
      if (!answerForm.requestSubmit || submitButton.disabled) return;
      if (!currentQuizId) return;
      const trimmedAnswer = answerInput.value.trim();
      if (!trimmedAnswer) return;

      event.preventDefault();
      answerForm.requestSubmit();
    }

    answerForm.addEventListener('submit', (event) => {
      event.preventDefault();
      if (!currentQuizId) return;
      const trimmedAnswer = answerInput.value.trim();
      if (!trimmedAnswer) return;
      setAnswerWaiting(true);
      socket.emit('player:answer', {
        quizId: currentQuizId,
        answer: trimmedAnswer,
      });
      answerFeedback.textContent = 'Answer submitted! Waiting for result...';
      answerFeedback.className = 'muted';
    });

    submitButton.addEventListener('pointerdown', handleImmediateSubmit);
    submitButton.addEventListener('touchstart', handleImmediateSubmit);

    answerInput.addEventListener('focus', handleInputFocus);
    answerInput.addEventListener('blur', handleInputBlur);

    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', () => {
        if (!inputEngaged) {
          baseViewportHeight = Math.max(baseViewportHeight, window.visualViewport.height);
          return;
        }

        const heightLoss = baseViewportHeight - window.visualViewport.height;
        if (heightLoss > 120) {
          window.requestAnimationFrame(adjustQuestionPosition);
        }
      });
    }

    window.addEventListener('resize', () => {
      if (!inputEngaged) {
        baseViewportHeight = Math.max(baseViewportHeight, window.innerHeight);
        return;
      }

      window.requestAnimationFrame(adjustQuestionPosition);
    });

    function showCorrectAnswer(text) {
      correctAnswerDisplay.textContent = text;
      correctAnswerDisplay.classList.toggle('visible', Boolean(text));
    }

    function setAnswerWaiting(isWaiting) {
      answerInput.disabled = isWaiting;
      submitButton.disabled = isWaiting;
    }

    function triggerFlash(isCorrect) {
      const variant = isCorrect ? 'flash-success' : 'flash-error';
      flashOverlay.className = `flash-overlay ${variant} active`;
      setTimeout(() => {
        flashOverlay.className = 'flash-overlay';
      }, 650);
    }

    function hideResultOverlay() {
      clearTimeout(resultOverlayTimeout);
      resultOverlayTimeout = null;
      resultOverlay.classList.remove('visible', 'correct', 'incorrect');
      resultOverlay.classList.add('hidden');
    }

    function showResultOverlay(isCorrect) {
      const variant = isCorrect ? 'correct' : 'incorrect';
      resultMessage.textContent = isCorrect ? 'Correct' : 'Incorrect';
      resultOverlay.classList.remove('hidden', 'correct', 'incorrect', 'visible');
      resultOverlay.classList.add(variant);
      window.requestAnimationFrame(() => {
        resultOverlay.classList.add('visible');
      });

      clearTimeout(resultOverlayTimeout);
      resultOverlayTimeout = setTimeout(() => {
        resultOverlay.classList.remove('visible');
        setTimeout(() => {
          resultOverlay.classList.add('hidden');
        }, 240);
      }, RESULT_OVERLAY_DURATION);
    }

    function handleInputFocus() {
      inputEngaged = true;
      document.body.classList.add('input-engaged');
      waitForKeyboardAndAdjust();
    }

    function handleInputBlur() {
      resetInputEngagement();
    }

    function resetInputEngagement() {
      inputEngaged = false;
      document.body.classList.remove('input-engaged');
      resetQuestionShift();
    }

    function waitForKeyboardAndAdjust(attempt = 0) {
      if (!inputEngaged) return;

      const viewportHeight = window.visualViewport?.height || window.innerHeight;
      const heightLoss = baseViewportHeight - viewportHeight;
      const keyboardLikelyOpen = heightLoss > 120;

      if (keyboardLikelyOpen) {
        window.requestAnimationFrame(adjustQuestionPosition);
        return;
      }

      if (attempt < 6) {
        setTimeout(() => waitForKeyboardAndAdjust(attempt + 1), 80);
      } else {
        window.requestAnimationFrame(adjustQuestionPosition);
      }
    }

    function adjustQuestionPosition() {
      if (!questionBoard || !questionContent || !answerInput) return;
      const questionRect = questionContent.getBoundingClientRect();
      const inputRect = answerInput.getBoundingClientRect();
      const desiredGap = 12;
      const rawShift = inputRect.top - questionRect.bottom - desiredGap;
      const boardRect = questionBoard.getBoundingClientRect();
      const maxShift = Math.max(0, boardRect.bottom - questionRect.bottom - 8);
      const safeShift = Math.min(Math.max(rawShift, 0), maxShift);

      if (safeShift > 2) {
        questionBoard.style.setProperty('--question-shift', `${safeShift}px`);
        questionBoard.classList.add('question-shifted');
      } else {
        resetQuestionShift();
      }
    }

    function resetQuestionShift() {
      questionBoard?.style.removeProperty('--question-shift');
      questionBoard?.classList.remove('question-shifted');
    }

    function startTimer(seconds) {
      stopTimer();
      let remaining = Math.round(seconds);
      if (!Number.isFinite(remaining) || remaining <= 0) {
        timerEl.textContent = 'Time!';
        return;
      }
      timerEl.textContent = `${remaining}s`;
      timerInterval = setInterval(() => {
        remaining -= 1;
        if (remaining <= 0) {
          timerEl.textContent = 'Time!';
          stopTimer();
          return;
        }
        timerEl.textContent = `${remaining}s`;
      }, 1000);
    }

    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    function renderLeaderboard(players) {
      leaderboard.innerHTML = '';
      if (!Array.isArray(players)) return;
      players.forEach((player, index) => {
        const li = document.createElement('li');
        li.innerHTML = `<span>${index + 1}. ${player.name}</span><span>${player.score} pts</span>`;
        leaderboard.appendChild(li);
      });
    }

    function renderMedia(media) {
      questionMedia.innerHTML = '';
      if (!media) return;
      if (media.type === 'image') {
        questionMedia.innerHTML = `<img src="${media.src}" alt="Question media" />`;
      } else if (media.type === 'audio') {
        questionMedia.innerHTML = `<audio controls src="${media.src}"></audio>`;
      } else if (media.type === 'video') {
        questionMedia.innerHTML = `<video controls src="${media.src}"></video>`;
      }
    }

    function hideOverlay() {
      overlay.classList.add('hidden');
      overlayList.innerHTML = '';
    }

    function toggleLeaderboard(show) {
      leaderboardCard.classList.add('hidden');
    }

    function startLobbyCountdown(seconds) {
      stopLobbyCountdown();
      let remaining = seconds;
      lobbyStatus.textContent = `Game starting in ${remaining}s...`;
      lobbyCountdown = setInterval(() => {
        remaining -= 1;
        lobbyStatus.textContent = `Game starting in ${Math.max(remaining, 0)}s...`;
        if (remaining <= 0) {
          stopLobbyCountdown();
        }
      }, 1000);
    }

    function stopLobbyCountdown() {
      if (lobbyCountdown) {
        clearInterval(lobbyCountdown);
        lobbyCountdown = null;
      }
      lobbyStatus.textContent = '';
    }

  </script>
</body>
</html>
