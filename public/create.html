<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no" />
  <title>Create Quiz</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body class="host">
  <div class="glow"></div>
  <header>
    <h1>Design your quiz</h1>
    <p>Write prompts, upload supporting media, and generate a session code for running the game.</p>
    <div class="cta-row">
      <a class="button ghost" href="/">Back to library</a>
      <a class="button ghost" href="/run.html">Go to run page</a>
    </div>
  </header>

  <main class="grid">
    <section class="card">
      <h2>Quiz details</h2>
      <form id="quiz-form">
        <label>
          Quiz title
          <input type="text" id="quiz-title" placeholder="Science quick-check" />
        </label>
        <label>
          Seconds per question
          <input type="number" id="question-duration" value="20" min="5" max="120" />
        </label>
        <div class="question-type-toggle">
          <span class="muted">Question type</span>
          <div class="toggle-options" role="radiogroup" aria-label="Question type">
            <label class="toggle-option">
              <input type="radio" name="question-type" value="open" checked />
              <span>Open response</span>
            </label>
            <label class="toggle-option">
              <input type="radio" name="question-type" value="multiple" />
              <span>Multiple choice</span>
            </label>
          </div>
        </div>
        <div class="questions" id="question-list"></div>
        <button type="button" class="ghost" id="add-question">+ Add question</button>
        <label>
          LLM grading context (optional)
          <textarea id="quiz-context" rows="6" placeholder="Add rubric notes or background context the LLM should use to grade answers."></textarea>
        </label>
        <label>
          LLM grading condition (optional)
          <input type="text" id="quiz-grading-condition" placeholder="Use present continuous for the answer" />
        </label>
        <div class="bulk-card">
          <h3>Bulk add questions</h3>
          <p class="muted" id="bulk-hint-open">Paste one question per line using pipes: <code>Question | Answer (optional) | Other acceptable answers</code>.</p>
          <p class="muted hidden" id="bulk-hint-multiple">Paste one question per line using pipes: <code>Question | Correct option | Incorrect option | Incorrect option | Incorrect option</code>.</p>
          <textarea id="bulk-questions" rows="6" placeholder="What is the powerhouse of the cell? | Mitochondria | The mitochondrion"></textarea>
          <div class="cta-row">
            <button type="button" class="ghost" id="bulk-preview">Preview additions</button>
            <button type="button" id="bulk-add">Add to quiz</button>
          </div>
          <p id="bulk-error" class="error"></p>
          <div id="bulk-preview-list" class="preview-list"></div>
        </div>
        <button type="submit">Create quiz</button>
        <p id="form-error" class="error"></p>
      </form>
    </section>

    <section class="card">
      <h2>Quiz code</h2>
      <div id="quiz-code" class="code">Waiting for quiz...</div>
      <p class="muted">After creating you'll get a fresh session code to share with players. Each run gets its own code.</p>
      <div id="host-credentials" class="credentials hidden">
        <p><strong>Session code:</strong> <span id="code-value"></span></p>
        <p><strong>Template code:</strong> <span id="template-value"></span></p>
        <p class="muted">Share the session code with players. Use the template code later to launch a brand-new session.</p>
        <div class="cta-row">
          <button id="copy-code" type="button" class="ghost">Copy session code</button>
          <button id="copy-template" type="button" class="ghost">Copy template code</button>
          <a id="run-link" class="button" href="/run.html">Open run page</a>
        </div>
      </div>
    </section>
  </main>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const questionList = document.getElementById('question-list');
    const addQuestionBtn = document.getElementById('add-question');
    const form = document.getElementById('quiz-form');
    const quizCodeEl = document.getElementById('quiz-code');
    const formError = document.getElementById('form-error');
    const credentials = document.getElementById('host-credentials');
    const codeValue = document.getElementById('code-value');
    const templateValue = document.getElementById('template-value');
    const runLink = document.getElementById('run-link');
    const copyCodeBtn = document.getElementById('copy-code');
    const copyTemplateBtn = document.getElementById('copy-template');
    const pageTitle = document.querySelector('title');
    const headerTitle = document.querySelector('header h1');
    const headerCopy = document.querySelector('header p');
    const submitButton = form.querySelector('button[type="submit"]');
    const questionDurationInput = document.getElementById('question-duration');
    const titleInput = document.getElementById('quiz-title');
    const contextInput = document.getElementById('quiz-context');
    const gradingConditionInput = document.getElementById('quiz-grading-condition');
    const questionTypeInputs = document.querySelectorAll('input[name="question-type"]');
    const bulkInput = document.getElementById('bulk-questions');
    const bulkHintOpen = document.getElementById('bulk-hint-open');
    const bulkHintMultiple = document.getElementById('bulk-hint-multiple');
    const params = new URLSearchParams(window.location.search);
    const editQuizId = params.get('quizId')?.trim()?.toUpperCase();
    const isEditMode = Boolean(editQuizId);
    let currentQuestionType = 'open';

    if (isEditMode) {
      pageTitle.textContent = 'Edit Quiz';
      headerTitle.textContent = 'Edit your quiz';
      headerCopy.textContent = 'Update prompts, answers, and grading rules for this quiz template.';
      submitButton.textContent = 'Save changes';
      quizCodeEl.textContent = `Editing quiz ${editQuizId}...`;
    }

    function renderMediaPreview(preview, media) {
      if (!media?.src) return;
      if (media.type === 'image') {
        preview.innerHTML = `<img src="${media.src}" alt="${media.name || 'Media preview'}" />`;
      } else if (media.type === 'audio') {
        preview.innerHTML = `<audio controls src="${media.src}"></audio>`;
      } else if (media.type === 'video') {
        preview.innerHTML = `<video controls src="${media.src}"></video>`;
      } else {
        preview.textContent = media.name || 'Attached media';
      }
    }

    function updateBulkHints() {
      const isMultiple = currentQuestionType === 'multiple';
      if (bulkHintOpen) bulkHintOpen.classList.toggle('hidden', isMultiple);
      if (bulkHintMultiple) bulkHintMultiple.classList.toggle('hidden', !isMultiple);
      if (bulkInput) {
        bulkInput.placeholder = isMultiple
          ? 'What is the powerhouse of the cell? | Mitochondria | Nucleus | Ribosome | Chloroplast'
          : 'What is the powerhouse of the cell? | Mitochondria | The mitochondrion';
      }
    }

    function applyQuestionTypeToRow(row) {
      if (!row) return;
      row.dataset.type = currentQuestionType;
      const openFields = row.querySelector('.open-fields');
      const choiceFields = row.querySelector('.choice-fields');
      if (openFields) openFields.classList.toggle('hidden', currentQuestionType !== 'open');
      if (choiceFields) choiceFields.classList.toggle('hidden', currentQuestionType !== 'multiple');
    }

    function applyQuestionTypeToRows() {
      questionList.querySelectorAll('.question-row').forEach(applyQuestionTypeToRow);
    }

    function setQuestionType(type) {
      currentQuestionType = type === 'multiple' ? 'multiple' : 'open';
      questionTypeInputs.forEach((input) => {
        input.checked = input.value === currentQuestionType;
      });
      applyQuestionTypeToRows();
      updateBulkHints();
    }

    function renderQuestionRow(index, question = {}) {
      const {
        prompt = '',
        answer = '',
        alternateAnswers = [],
        partialAnswers = [],
        incorrectOptions = [],
        media = null,
      } = question;
      const incorrect = Array.isArray(incorrectOptions) ? incorrectOptions : [];
      const [incorrectOne = '', incorrectTwo = '', incorrectThree = ''] = incorrect;
      const wrapper = document.createElement('div');
      wrapper.className = 'question-row media';
      wrapper.innerHTML = `
        <div>
          <label class="question-prompt">
            <span class="question-number" data-role="question-number">Question ${index + 1}</span>
            <input type="text" name="prompt" placeholder="What is photosynthesis?" value="${prompt}" required />
          </label>
          <div class="open-fields">
            <label>Expected answer
              <input type="text" name="answer" placeholder="A process plants use to make food" value="${answer}" />
            </label>
            <label>Alternate answers (separate with ||)
              <input type="text" name="alternate" placeholder="Other phrasing that should count as correct (use || between options)" value="${alternateAnswers.join(' || ')}" />
            </label>
            <label>Partial credit answers (synonyms or near-misses, use ||)
              <input type="text" name="partial" placeholder="Counts for half points (use || between options)" value="${partialAnswers.join(' || ')}" />
            </label>
          </div>
          <div class="choice-fields hidden">
            <label>Correct option
              <input type="text" name="correct" placeholder="Mitochondria" value="${answer}" />
            </label>
            <label>Incorrect option 1
              <input type="text" name="incorrect-0" placeholder="Nucleus" value="${incorrectOne}" />
            </label>
            <label>Incorrect option 2
              <input type="text" name="incorrect-1" placeholder="Ribosome" value="${incorrectTwo}" />
            </label>
            <label>Incorrect option 3
              <input type="text" name="incorrect-2" placeholder="Chloroplast" value="${incorrectThree}" />
            </label>
          </div>
        </div>
        <div class="media-picker">
          <label class="file-label">Attach media (photo, audio, or video)
            <input type="file" accept="image/*,audio/*,video/*" name="media" />
          </label>
          <div class="preview" aria-live="polite"></div>
          <button type="button" class="ghost clear-media">Remove media</button>
        </div>
        <button type="button" class="ghost remove">Remove</button>
      `;
      wrapper.querySelector('.remove').addEventListener('click', () => {
        wrapper.remove();
        updateQuestionLabels();
      });
      const mediaInput = wrapper.querySelector('input[name="media"]');
      const preview = wrapper.querySelector('.preview');
      const clearMediaBtn = wrapper.querySelector('.clear-media');
      mediaInput.addEventListener('change', (event) => {
        preview.innerHTML = '';
        const file = event.target.files?.[0];
        wrapper.dataset.existingMedia = '';
        if (!file) return;
        const type = file.type;
        if (type.startsWith('image/')) {
          preview.innerHTML = `<img src="${URL.createObjectURL(file)}" alt="Image preview" />`;
        } else if (type.startsWith('audio/')) {
          preview.innerHTML = `<audio controls src="${URL.createObjectURL(file)}"></audio>`;
        } else if (type.startsWith('video/')) {
          preview.innerHTML = `<video controls src="${URL.createObjectURL(file)}"></video>`;
        } else {
          preview.textContent = file.name;
        }
      });
      clearMediaBtn.addEventListener('click', () => {
        mediaInput.value = '';
        wrapper.dataset.existingMedia = '';
        preview.innerHTML = '';
      });
      if (media) {
        wrapper.dataset.existingMedia = JSON.stringify(media);
        renderMediaPreview(preview, media);
      }
      applyQuestionTypeToRow(wrapper);
      questionList.appendChild(wrapper);
    }

    function updateQuestionLabels() {
      questionList.querySelectorAll('.question-row').forEach((row, idx) => {
        const label = row.querySelector('[data-role="question-number"]');
        if (label) {
          label.textContent = `Question ${idx + 1}`;
        }
      });
    }

    function readFileAsDataURL(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = (error) => reject(error);
        reader.readAsDataURL(file);
      });
    }

    async function buildQuestions(context) {
      const rows = Array.from(questionList.querySelectorAll('.question-row'));
      const questions = [];
      for (const [index, row] of rows.entries()) {
        const prompt = row.querySelector('input[name="prompt"]').value;
        if (currentQuestionType === 'multiple') {
          const correctOption = row.querySelector('input[name="correct"]').value;
          const incorrectInputs = Array.from(row.querySelectorAll('input[name^="incorrect-"]'));
          const incorrectOptions = incorrectInputs
            .map((input) => input.value.trim())
            .filter(Boolean);
          if (!correctOption.trim()) {
            throw new Error(`Question ${index + 1} needs a correct option.`);
          }
          if (incorrectOptions.length < 3) {
            throw new Error(`Question ${index + 1} needs three incorrect options.`);
          }

          const mediaInput = row.querySelector('input[name="media"]');
          const file = mediaInput?.files?.[0];
          let media = null;
          if (file) {
            const src = await readFileAsDataURL(file);
            let type = 'file';
            if (file.type.startsWith('image/')) type = 'image';
            else if (file.type.startsWith('audio/')) type = 'audio';
            else if (file.type.startsWith('video/')) type = 'video';
            media = { type, name: file.name, src };
          } else if (row.dataset.existingMedia) {
            try {
              media = JSON.parse(row.dataset.existingMedia);
            } catch (error) {
              media = null;
            }
          }

          questions.push({
            prompt,
            type: 'multiple',
            answer: correctOption,
            incorrectOptions,
            media,
          });
          continue;
        }

        const answer = row.querySelector('input[name="answer"]').value;
        if (!answer.trim() && !context.trim()) {
          throw new Error(`Question ${index + 1} needs an expected answer or quiz context for LLM grading.`);
        }
        const alternateRaw = row.querySelector('input[name="alternate"]').value;
        const partialRaw = row.querySelector('input[name="partial"]').value;
        const alternateAnswers = alternateRaw
          .split(/\|\|/)
          .map((part) => part.trim())
          .filter(Boolean);
        const partialAnswers = partialRaw
          .split(/\|\|/)
          .map((part) => part.trim())
          .filter(Boolean);
        const mediaInput = row.querySelector('input[name="media"]');
        const file = mediaInput?.files?.[0];
        let media = null;
        if (file) {
          const src = await readFileAsDataURL(file);
          let type = 'file';
          if (file.type.startsWith('image/')) type = 'image';
          else if (file.type.startsWith('audio/')) type = 'audio';
          else if (file.type.startsWith('video/')) type = 'video';
          media = { type, name: file.name, src };
        } else if (row.dataset.existingMedia) {
          try {
            media = JSON.parse(row.dataset.existingMedia);
          } catch (error) {
            media = null;
          }
        }
        questions.push({
          prompt,
          type: 'open',
          answer,
          alternateAnswers,
          partialAnswers,
          media,
        });
      }
      return questions;
    }

    function parseBulkQuestions(raw) {
      const lines = raw
        .split(/\n|\r/)
        .map((line) => line.trim())
        .filter(Boolean);

      const parsed = lines.map((line) => {
        const parts = line.split(/\|/).map((part) => part.trim());
        const [prompt, first = '', ...rest] = parts;

        if (currentQuestionType === 'multiple') {
          return {
            prompt,
            answer: first,
            incorrectOptions: rest.filter(Boolean),
            type: 'multiple',
          };
        }

        return { prompt, answer: first, alternateAnswers: rest.filter(Boolean), type: 'open' };
      });

      return parsed.filter((q) => q.prompt);
    }

    function renderBulkPreview(questions) {
      const preview = document.getElementById('bulk-preview-list');
      preview.innerHTML = '';
      questions.forEach((q, idx) => {
        const item = document.createElement('div');
        item.className = 'preview-item';
        if (currentQuestionType === 'multiple') {
          const options = [q.answer, ...(q.incorrectOptions || [])].filter(Boolean);
          const optionText = options.length ? ` → ${options.join(' | ')}` : '';
          item.textContent = `${idx + 1}. ${q.prompt}${optionText}`;
        } else {
          const alternates = q.alternateAnswers?.length ? ` | Variants: ${q.alternateAnswers.join(' || ')}` : '';
          const answerText = q.answer ? ` → ${q.answer}` : '';
          item.textContent = `${idx + 1}. ${q.prompt}${answerText}${alternates}`;
        }
        preview.appendChild(item);
      });
    }

    function appendBulkQuestions(questions) {
      questions.forEach((q) => {
        renderQuestionRow(questionList.children.length, q);
      });
      updateQuestionLabels();
    }

    const bulkPreviewBtn = document.getElementById('bulk-preview');
    const bulkAddBtn = document.getElementById('bulk-add');
    const bulkError = document.getElementById('bulk-error');

    bulkPreviewBtn.addEventListener('click', () => {
      bulkError.textContent = '';
      const parsed = parseBulkQuestions(bulkInput.value);
      if (!parsed.length) {
        bulkError.textContent = 'Enter at least one line with a question.';
        return;
      }
      if (currentQuestionType === 'multiple') {
        const invalid = parsed.find((q) => !q.answer?.trim() || (q.incorrectOptions || []).length < 3);
        if (invalid) {
          bulkError.textContent = 'Each line needs a correct option and three incorrect options.';
          return;
        }
      }
      renderBulkPreview(parsed);
    });

    bulkAddBtn.addEventListener('click', () => {
      bulkError.textContent = '';
      const parsed = parseBulkQuestions(bulkInput.value);
      if (!parsed.length) {
        bulkError.textContent = 'Enter at least one line with a question.';
        return;
      }
      if (currentQuestionType === 'multiple') {
        const invalid = parsed.find((q) => !q.answer?.trim() || (q.incorrectOptions || []).length < 3);
        if (invalid) {
          bulkError.textContent = 'Each line needs a correct option and three incorrect options.';
          return;
        }
      }
      appendBulkQuestions(parsed);
      renderBulkPreview([]);
      bulkInput.value = '';
    });

    questionTypeInputs.forEach((input) => {
      input.addEventListener('change', () => {
        if (input.checked) {
          setQuestionType(input.value);
        }
      });
    });

    addQuestionBtn.addEventListener('click', () => renderQuestionRow(questionList.children.length));

    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      formError.textContent = '';
      quizCodeEl.textContent = isEditMode ? 'Saving changes...' : 'Creating quiz...';
      try {
        const context = contextInput.value;
        const questions = await buildQuestions(context);
        const title = titleInput.value;
        const questionDuration = questionDurationInput.value;
        const gradingCondition = gradingConditionInput.value;

        if (isEditMode) {
          const response = await fetch(`/api/quizzes/${editQuizId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              title,
              questions,
              questionDuration,
              context,
              gradingCondition,
            }),
          });
          if (!response.ok) {
            const data = await response.json().catch(() => ({}));
            throw new Error(data.error || 'Unable to save quiz changes.');
          }
          quizCodeEl.textContent = `Saved changes to quiz ${editQuizId}.`;
        } else {
          socket.emit('host:createQuiz', {
            title,
            questions,
            questionDuration,
            context,
            gradingCondition,
          });
        }
      } catch (error) {
        formError.textContent = error?.message || 'Unable to build quiz questions.';
        quizCodeEl.textContent = 'Waiting for quiz...';
      }
    });

    socket.on('host:error', (message) => {
      formError.textContent = message;
      quizCodeEl.textContent = 'Waiting for quiz...';
    });

    socket.on('host:quizCreated', ({ quizId, templateId }) => {
      quizCodeEl.textContent = `Share this session code: ${quizId}`;
      credentials.classList.remove('hidden');
      codeValue.textContent = quizId;
      templateValue.textContent = templateId;
      runLink.href = `/run.html?quizId=${quizId}`;
      sessionStorage.setItem('quizId', quizId);
      sessionStorage.setItem('templateId', templateId);
    });

    copyCodeBtn.addEventListener('click', () => {
      if (!codeValue.textContent) return;
      navigator.clipboard.writeText(codeValue.textContent);
      copyCodeBtn.textContent = 'Copied!';
      setTimeout(() => { copyCodeBtn.textContent = 'Copy code'; }, 1200);
    });

    copyTemplateBtn.addEventListener('click', () => {
      if (!templateValue.textContent) return;
      navigator.clipboard.writeText(templateValue.textContent);
      copyTemplateBtn.textContent = 'Copied!';
      setTimeout(() => { copyTemplateBtn.textContent = 'Copy template code'; }, 1200);
    });

    async function loadQuizForEdit() {
      try {
        const response = await fetch(`/api/quizzes/${editQuizId}/template`);
        if (!response.ok) {
          throw new Error('Unable to load quiz for editing.');
        }
        const data = await response.json();
        questionList.innerHTML = '';
        titleInput.value = data.title || '';
        questionDurationInput.value = data.questionDuration || 20;
        contextInput.value = data.context || '';
        gradingConditionInput.value = data.gradingCondition || '';
        const questionsData = Array.isArray(data.questions) ? data.questions : [];
        const hasMultiple = questionsData.some((question) => {
          const type = String(question?.type ?? '').toLowerCase();
          if (type === 'multiple' || type === 'multiple-choice' || type === 'mc') return true;
          const incorrectOptions = Array.isArray(question?.incorrectOptions)
            ? question.incorrectOptions.filter((option) => String(option ?? '').trim())
            : [];
          if (incorrectOptions.length) return true;
          const options = Array.isArray(question?.options)
            ? question.options.filter((option) => String(option ?? '').trim())
            : [];
          return options.length >= 2;
        });
        setQuestionType(hasMultiple ? 'multiple' : 'open');
        questionsData.forEach((question, index) => {
          const incorrectOptions = Array.isArray(question.incorrectOptions)
            ? question.incorrectOptions
            : Array.isArray(question.options)
              ? question.options.filter((option) => String(option).trim() !== String(question.answer ?? '').trim())
              : [];
          renderQuestionRow(index, {
            prompt: question.prompt || '',
            answer: question.answer || '',
            alternateAnswers: question.alternateAnswers || [],
            partialAnswers: question.partialAnswers || [],
            incorrectOptions,
            media: question.media || null,
          });
        });
        if (!questionList.children.length) {
          renderQuestionRow(0);
        }
      } catch (error) {
        formError.textContent = error?.message || 'Unable to load quiz for editing.';
        setQuestionType('open');
        if (!questionList.children.length) {
          renderQuestionRow(0);
        }
      }
    }

    if (isEditMode) {
      loadQuizForEdit();
    } else {
      setQuestionType('open');
      renderQuestionRow(0);
    }
  </script>
</body>
</html>
